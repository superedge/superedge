package steps

import (
	"errors"
	"fmt"
	"github.com/superedge/superedge/pkg/util/kubeadm/app/cmd/options"
	phases "github.com/superedge/superedge/pkg/util/kubeadm/app/cmd/phases/init"
	"github.com/superedge/superedge/pkg/util/kubeadm/app/cmd/phases/workflow"
	cmdutil "github.com/superedge/superedge/pkg/util/kubeadm/app/cmd/util"
	kubeadmconstants "github.com/superedge/superedge/pkg/util/kubeadm/app/constants"
)

////////////////
var (
	controlPlaneExample = cmdutil.Examples(`
		# Generates all static Pod manifest files for control plane components,
		# functionally equivalent to what is generated by kubeadm init.
		kubeadm init phase control-plane all

		# Generates all static Pod manifest files using options read from a configuration file.
		kubeadm init phase control-plane all --config config.yaml
		`)

	controlPlanePhaseProperties = map[string]struct {
		name  string
		short string
	}{
		kubeadmconstants.KubeAPIServer: {
			name:  "apiserver",
			short: getPhaseDescription(kubeadmconstants.KubeAPIServer),
		},
		kubeadmconstants.KubeControllerManager: {
			name:  "controller-manager",
			short: getPhaseDescription(kubeadmconstants.KubeControllerManager),
		},
		kubeadmconstants.KubeScheduler: {
			name:  "scheduler",
			short: getPhaseDescription(kubeadmconstants.KubeScheduler),
		},
	}
)

func getPhaseDescription(component string) string {
	return fmt.Sprintf("Generates the %s static Pod manifest", component)
}

// NewControlPlanePhase creates a kubeadm workflow phase that implements bootstrapping the control plane.
func NewControlPlanePhase() workflow.Phase {
	phase := workflow.Phase{
		Name:  "control-plane",
		Short: "Generate all static Pod manifest files necessary to establish the control plane",
		Long:  cmdutil.MacroCommandLongDescription,
		Phases: []workflow.Phase{
			{
				Name:           "all",
				Short:          "Generate all static Pod manifest files",
				InheritFlags:   getControlPlanePhaseFlags("all"),
				Example:        controlPlaneExample,
				RunAllSiblings: true,
			},
			newControlPlaneSubphase(kubeadmconstants.KubeAPIServer),
			newControlPlaneSubphase(kubeadmconstants.KubeControllerManager),
			newControlPlaneSubphase(kubeadmconstants.KubeScheduler),
		},
		Run: runControlPlanePhase,
	}
	return phase
}

func newControlPlaneSubphase(component string) workflow.Phase {
	phase := workflow.Phase{
		Name:         controlPlanePhaseProperties[component].name,
		Short:        controlPlanePhaseProperties[component].short,
		Run:          runControlPlaneSubphase(component),
		InheritFlags: getControlPlanePhaseFlags(component),
	}
	return phase
}

func getControlPlanePhaseFlags(name string) []string {
	flags := []string{
		options.CfgPath,
		options.CertificatesDir,
		options.KubernetesVersion,
		options.ImageRepository,
		options.Patches,
	}
	if name == "all" || name == kubeadmconstants.KubeAPIServer {
		flags = append(flags,
			options.APIServerAdvertiseAddress,
			options.ControlPlaneEndpoint,
			options.APIServerBindPort,
			options.APIServerExtraArgs,
			options.FeatureGatesString,
			options.NetworkingServiceSubnet,
		)
	}
	if name == "all" || name == kubeadmconstants.KubeControllerManager {
		flags = append(flags,
			options.ControllerManagerExtraArgs,
			options.NetworkingPodSubnet,
		)
	}
	if name == "all" || name == kubeadmconstants.KubeScheduler {
		flags = append(flags,
			options.SchedulerExtraArgs,
		)
	}
	return flags
}

func runControlPlanePhase(c workflow.RunData) error {
	data, ok := c.(phases.InitData)
	if !ok {
		return errors.New("control-plane phase invoked with an invalid data struct")
	}

	fmt.Printf("[control-plane] Using manifest folder %q\n", data.ManifestDir())
	return nil
}

func runControlPlaneSubphase(component string) func(c workflow.RunData) error {
	return func(c workflow.RunData) error {
		data, ok := c.(phases.InitData)
		if !ok {
			return errors.New("control-plane phase invoked with an invalid data struct")
		}
		cfg := data.Cfg()

		fmt.Printf("[control-plane] Creating static Pod manifest for %q, %s\n", component, cfg)
		return nil
	}
}
////////////////
// NewControlPlanePhase creates a kubeadm workflow phase that implements bootstrapping the control plane.
func NewEdgeAppsPhase() workflow.Phase {
	phase := workflow.Phase{
		Name:  "edge-apps",
		Short: "Deploy edge apps",
		Long:  cmdutil.MacroCommandLongDescription,
		Phases: []workflow.Phase{
			{
				Name:           "all",
				Short:          "Deploy all edge apps",
				InheritFlags:   getControlPlanePhaseFlags("all"),
				Example:        controlPlaneExample,
				RunAllSiblings: true,
			},
			newTunnelCloudSubphase(kubeadmconstants.KubeAPIServer),
			//newControlPlaneSubphase(kubeadmconstants.KubeControllerManager),
			//newControlPlaneSubphase(kubeadmconstants.KubeScheduler),
		},
		Run: runDeployEdgeAppsPhase,
	}
	return phase
}


func runDeployEdgeAppsPhase(c workflow.RunData) error {
	data, ok := c.(phases.InitData)
	if !ok {
		return errors.New("Deploy edge-apps phase invoked with an invalid data struct\n")
	}

	fmt.Printf("[edge-apps] Using manifest folder %q\n", data.ManifestDir())
	return nil
}

func newTunnelCloudSubphase(component string) workflow.Phase {
	phase := workflow.Phase{
		Name:         controlPlanePhaseProperties[component].name,
		Short:        controlPlanePhaseProperties[component].short,
		Run:          runControlPlaneSubphase(component),
		InheritFlags: getTunnelCloudPhaseFlags(component),
	}
	return phase
}


func getTunnelCloudPhaseFlags(name string) []string {
	flags := []string{
		options.CfgPath,
		options.CertificatesDir,
		options.KubernetesVersion,
		options.ImageRepository,
		options.Patches,
	}
	if name == "all" || name == kubeadmconstants.KubeAPIServer {
		flags = append(flags,
			options.APIServerAdvertiseAddress,
			options.ControlPlaneEndpoint,
			options.APIServerBindPort,
			options.APIServerExtraArgs,
			options.FeatureGatesString,
			options.NetworkingServiceSubnet,
		)
	}
	if name == "all" || name == kubeadmconstants.KubeControllerManager {
		flags = append(flags,
			options.ControllerManagerExtraArgs,
			options.NetworkingPodSubnet,
		)
	}
	if name == "all" || name == kubeadmconstants.KubeScheduler {
		flags = append(flags,
			options.SchedulerExtraArgs,
		)
	}
	return flags
}